from langchain_groq import ChatGroq
import json

"""
Support Agent for Fixing AQL Query Execution Errors

This agent is called when the AQL query generated by Agent 2 fails. 
Its goal is to refine the previous query based on the execution error and improve it 
to ensure successful execution.

The agent MUST strictly follow the database schema and correct any mistakes 
while maintaining the user intent.
"""

def support_agent_for_agent_2(error: str, failed_query: str, api_key: str):
    try:
        # Initialise the LLM
        llm = ChatGroq(
            api_key=api_key,
            temperature=0,
            model_name="llama3-70b-8192"
        )

        # Improved Prompt for Query Refinement
        prompt = f"""
        üîπ You are an expert in **ArangoDB AQL queries**. 
        Your task is to **fix a previously failed AQL query** based on the given **execution error**.
        
        **üî¥ CRITICAL CONSTRAINTS:**  
        - **NEVER retrieve entire collections without filters** - this causes system overload
        - **ALWAYS use indexed fields** (`_key`, `type`, `institution`) in FILTER clauses when possible
        - **LIMIT results** to a reasonable number (default: 100) unless specified otherwise
        - **RETURN only the raw AQL query** - no code blocks, quotes, or explanations
        
        **üõ† ERROR MESSAGE:**  
        
        {error}
        ```

        **‚ùå FAILED AQL QUERY:**  
        ```
        {failed_query}
        ```

        ---  
   
        **üìä DATABASE SCHEMA**  
        **Collection: financial_nodes**
        | Field | Type | Description | Indexed |
        |-------|------|-------------|---------|
        | _key | String | Unique identifier | ‚úì |
        | type | String | Product type (bank, Current Account, Loan, High Yield Savings, ISA, Bond, Credit Card) | ‚úì |
        | institution | String | Financial institution name | ‚úì |
        | interest_rate | Float | Interest rate percentage | ‚úó |
        | fees | Float | Associated fees | ‚úó |
        | rewards | Array | List of benefits/rewards | ‚úó |
        | loan_amount | Integer | Loan amount if applicable | ‚úó |
        
        **Collection: financial_edges**
        | Field | Type | Description | Indexed |
        |-------|------|-------------|---------|
        | _from | String | Source node ID | ‚úì |
        | _to | String | Target node ID | ‚úì |
        | relationship | String | Relationship type (offers, related) | ‚úì |
        
        **üîç QUERY OPTIMIZATION RULES:**
        1. Use `FILTER` with indexed fields first
        2. Apply `LIMIT` to prevent excessive results
        3. Use `LET` for complex subqueries
        4. Include `SORT` for ordered results
        5. Return specific fields instead of entire documents
        6. Use graph traversals for relationship queries
        
        **‚ö° PERFORMANCE TIPS:**
        - Prefer `==` over `IN` for single value comparisons
        - Use `COLLECT` for aggregations instead of client-side processing
        - Apply `FILTER` before expensive operations
        
        **üîÑ ERROR RESOLUTION PRIORITIES:**
        1. **FUNCTIONALITY OVER OPTIMIZATION** - If any optimization rule causes an error, remove or modify it:
           - If `LIMIT` causes an error, remove it completely
           - If `SORT` causes an error, remove the sort clause
           - If a specific `FILTER` condition causes an error, try alternative syntax or remove it
           - If `COLLECT` causes an error, use a simpler approach
        2. **SYNTAX OVER STRUCTURE** - Fix syntax errors first, then address structural issues
        3. **FIELD EXISTENCE** - Check if referenced fields actually exist in the schema
        4. **TYPE COMPATIBILITY** - Ensure operations match field data types (string vs. number comparisons)
        5. **QUERY SIMPLIFICATION** - If complex queries fail, simplify by removing optional clauses
        
        **‚úÖ FIXED QUERY (RETURN ONLY THIS):**
        """

        # Use the Groq client to process the query
        llm_response = llm.invoke(prompt)

        # Log the full response for debugging
        print(f"Full response from Groq: {llm_response}")

        # Ensure only the corrected query is extracted
        if hasattr(llm_response, 'content'):
            llm_response_content = llm_response.content.strip()
            print(f"Generated AQL Query: {llm_response_content}")
            return {"status": 200, "data": llm_response_content}
        else:
            # Log and return error if 'content' is not found in the response
            error_message = "Groq API response does not have 'content'"
            print(f"Error: {error_message}")
            return {"status": 500, "error": error_message}

    except ConnectionError as ce:
        # Handle network or connection-related issues
        error_message = f"Network/Connection Error: {str(ce)}"
        print(f"Error: {error_message}")
        return {"status": 500, "error": error_message}

    except TimeoutError as te:
        # Handle timeout errors
        error_message = f"Timeout Error: {str(te)}"
        print(f"Error: {error_message}")
        return {"status": 500, "error": error_message}

    except Exception as e:
        # Catch any other errors
        error_message = f"Error in AQL Query generation agent: {str(e)}"
        print(f"Error: {error_message}")
        return {"status": 500, "error": error_message}
