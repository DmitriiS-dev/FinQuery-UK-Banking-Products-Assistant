from langchain_groq import ChatGroq
import json

"""
Support Agent for Fixing AQL Query Execution Errors

This agent is called when the AQL query generated by Agent 2 fails. 
Its goal is to refine the previous query based on the execution error and improve it 
to ensure successful execution.

The agent MUST strictly follow the database schema and correct any mistakes 
while maintaining the user intent.
"""

def support_agent_for_agent_2(error: str, failed_query: str, api_key: str):
    try:
        # Initialise the LLM
        llm = ChatGroq(
            api_key=api_key,
            temperature=0,
            model_name="llama3-70b-8192"
        )

        # Improved Prompt for Query Refinement
        prompt = f"""
        üîπ You are an expert in **ArangoDB AQL queries**. 
        Your task is to **fix a previously failed AQL query** based on the given **execution error**.
        
        THIS IS VERY IMPORTANT: - YOU WILL RETURN only the raw AQL query** - no code blocks, quotes, or explanations
        
        **üî¥ CRITICAL CONSTRAINTS:**  
        - **NEVER retrieve entire collections without filters** - this causes system overload
        - **ALWAYS use indexed fields** ( `type`, `institution`) in FILTER clauses when possible        
        **üõ† ERROR MESSAGE:**  
        
        {error}
        ```

        **‚ùå FAILED AQL QUERY:**  
        ```
        {failed_query}
        ```

        ---  
   
        **üìä DATABASE SCHEMA**  
        DATABASE SCHEMA:
        - **Collection:** `financial_nodes`
            - **_key** *(String)*: Unique identifier for the financial product.
            - **type** *(String)*: The type of financial product.
              - Possible values: `"bank"`, `"Current Account"`, `"Loan"`, `"High Yield Savings"`, `"ISA"`, `"Bond"`, `"Credit Card"`
            - **institution** *(String)*: The name of the bank or financial institution offering the product.
                        ["Barclays", "HSBC", "Lloyds Bank", "NatWest", "Santander", "TSB", 
                "RBS", "Halifax", "Nationwide", "Yorkshire Building Society", 
                "Coventry Building Society", "Skipton Building Society", "Leeds Building Society", 
                "Newcastle Building Society", "Principality Building Society", "Monzo", 
                "Starling Bank", "Revolut", "Atom Bank", "Tandem Bank", "Goldman Sachs (Marcus UK)", 
                "Close Brothers", "Shawbrook Bank", "Aldermore Bank", "Zopa"]
            - **interest_rate** *(Float)*: Interest rate associated with the financial product (if applicable).
            - **fees** *(Float)*: Fees associated with the product.
            - **rewards** *(List[String])*: A list of benefits/rewards for the product.
                'Cashback on purchases', 'Travel discounts', 'Airport lounge access',
                'Discounted travel insurance', 'Exclusive event invites', 'Bonus loyalty points',
                'Free overdraft protection', 'Higher interest rates on savings', 
                'Free foreign ATM withdrawals', 'No fees on international transfers', 'Fuel discounts'
            - **loan_amount** *(Integer)*: The loan amount if applicable.

        - Collection: `financial_edges`
            - `_from`: Link to a `financial_node` (bank or financial product).
            - `_to`: Link to another `financial_node` (related financial product).
            - `relationship`: Relationship type (e.g., "offers", "related", etc.).
        """

        part_two ="""
        **‚úÖ FIXED QUERY Example (You would only need 1 ):**
        FOR node IN financial_nodes  
        FILTER node.type == "ISA"  
        AND node.account_type IN ["Cash ISA", "Fixed-rate ISA", "Flexible ISA", "Lifetime ISA", "Stocks & Shares ISA"]  
        RETURN { 
            institution: node.institution,  
            product: node._key,  
            interest_rate: node.interest_rate,  
            fees: node.fees,  
            rewards: node.rewards  
        }
        """


        # Use the Groq client to process the query
        llm_response = llm.invoke(prompt+part_two)

        # Log the full response for debugging
        print(f"Full response from Groq: {llm_response}")

        # Ensure only the corrected query is extracted
        if hasattr(llm_response, 'content'):
            llm_response_content = llm_response.content.strip()
            print(f"Generated AQL Query: {llm_response_content}")
            return {"status": 200, "data": llm_response_content}
        else:
            # Log and return error if 'content' is not found in the response
            error_message = "Groq API response does not have 'content'"
            print(f"Error: {error_message}")
            return {"status": 500, "error": error_message}

    except ConnectionError as ce:
        # Handle network or connection-related issues
        error_message = f"Network/Connection Error: {str(ce)}"
        print(f"Error: {error_message}")
        return {"status": 500, "error": error_message}

    except TimeoutError as te:
        # Handle timeout errors
        error_message = f"Timeout Error: {str(te)}"
        print(f"Error: {error_message}")
        return {"status": 500, "error": error_message}

    except Exception as e:
        # Catch any other errors
        error_message = f"Error in AQL Query generation agent: {str(e)}"
        print(f"Error: {error_message}")
        return {"status": 500, "error": error_message}
